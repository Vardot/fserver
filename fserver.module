<?php
/**
 * @file
 * Code for the Feature Server feature.
 */

include_once 'fserver.features.inc';

define("FSERVER_VIEW_NAME_PROJECTS_ALL", 'fserver_projects');
define("FSERVER_VIEW_NAME_PROJECTS_SINGLE", 'fserver_project');

/**
 * Implements hook_entity_info().
 */
function fserver_entity_info() {
  $info = array();

  $info['project_type'] = array(
    'label' => t('Project Type'),
    'controller class' => 'EntityAPIControllerExportable',
    'entity class' => 'Entity',
    'base table' => 'fserver_project_type',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'id',
      'label' => 'description',
      'name' => 'type',
      'uuid' => 'uuid'
    ),
    'bundle of' => 'project',
    'exportable' => TRUE,
    'export' => array(
      'default hook' => 'default_project_type',
    ),
    'uuid' => TRUE,
    'module' => 'fserver',
    'access callback' => 'fserver_project_type_access',
    'entity cache' => module_exists('entitycache'),
    'metadata controller class' => 'FserverProjectTypeMetadataController',
    'admin ui' => array(
      'path' => 'admin/structure/project_types',
      'file' => 'includes/fserver.admin.inc',
    ),
  );

  $info['release_type'] = array(
    'label' => t('Release Type'),
    'controller class' => 'EntityAPIControllerExportable',
    'entity class' => 'Entity',
    'base table' => 'fserver_release_type',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'id',
      'label' => 'description',
      'name' => 'type',
      'uuid' => 'uuid'
    ),
    'bundle of' => 'release',
    'exportable' => TRUE,
    'export' => array(
      'default hook' => 'default_release_type',
    ),
    'uuid' => TRUE,
    'module' => 'fserver',
    'access callback' => 'fserver_project_type_access',
    'entity cache' => module_exists('entitycache'),
    'metadata controller class' => 'FserverReleaseTypeMetadataController',
    'admin ui' => array(
      'path' => 'admin/structure/release_types',
      'file' => 'includes/fserver.admin.inc',
    ),
  );

  $info['project'] = array();
  $info['release'] = array();

  // @todo

  /*  Bundles to be converted to default exports of bundle type
  $items = array(
  'project_distribution' => array(
  'machine_name' => 'project_distribution',
  'entity_type' => 'project',
  'name' => 'distribution',
  'label' => 'Distribution',
),
  'project_module' => array(
  'machine_name' => 'project_module',
  'entity_type' => 'project',
  'name' => 'module',
  'label' => 'Module',
),
  'project_theme' => array(
  'machine_name' => 'project_theme',
  'entity_type' => 'project',
  'name' => 'theme',
  'label' => 'Theme',
),
  'release_release' => array(
  'machine_name' => 'release_release',
  'entity_type' => 'release',
  'name' => 'release',
  'label' => 'Release',
),
  );
  return $items;
}*/
  return $info;
}

/**
 * Access callback for project types
 */
function fserver_project_type_access($op, $entity, $account, $entity_type) {
  // @todo
  return TRUE:
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function fserver_ctools_plugin_directory($owner, $plugin_type) {
  if ($owner == 'eck' && $plugin_type == 'property_behavior') {
    return 'plugins/' . $plugin_type;
  }
}

// @todo replace with something similar to https://git.dropfort.com/dropfort/dropfort_project/blob/7.x-1.x/dropfort_project.module#L622
/**
 * Implements hook_form_alter().
 */
function fserver_form_eck__entity__form_add_project_module_alter(&$form, &$form_state) {
  module_load_include('inc', 'fserver', 'fserver.pages');
  fserver_project_form($form, $form_state);
}

/**
 * Implements hook_form_alter().
 */
function fserver_form_eck__entity__form_edit_project_module_alter(&$form, &$form_state) {
  module_load_include('inc', 'fserver', 'fserver.pages');
  fserver_project_form($form, $form_state);
}

/**
 * Implements hook_form_alter().
 */
function fserver_form_eck__entity__form_add_project_theme_alter(&$form, &$form_state) {
  module_load_include('inc', 'fserver', 'fserver.pages');
  fserver_project_form($form, $form_state);
}

/**
 * Implements hook_form_alter().
 */
function fserver_form_eck__entity__form_edit_project_theme_alter(&$form, &$form_state) {
  module_load_include('inc', 'fserver', 'fserver.pages');
  fserver_project_form($form, $form_state);
}


/**
 * Implements hook_form_alter().
 */
function fserver_form_eck__entity__form_add_project_distribution_alter(&$form, &$form_state) {
  module_load_include('inc', 'fserver', 'fserver.pages');
  fserver_project_form($form, $form_state);
}

/**
 * Implements hook_form_alter().
 */
function fserver_form_eck__entity__form_edit_project_distribution_alter(&$form, &$form_state) {
  module_load_include('inc', 'fserver', 'fserver.pages');
  fserver_project_form($form, $form_state);
}

/**
 * Implements hook_form_alter().
 */
function fserver_form_eck__entity__form_add_release_release_alter(&$form, &$form_state) {
  module_load_include('inc', 'fserver', 'fserver.pages');
  fserver_release_form($form, $form_state);
}

/**
 * Implements hook_form_alter().
 */
function fserver_form_eck__entity__form_edit_release_release_alter(&$form, &$form_state) {
  module_load_include('inc', 'fserver', 'fserver.pages');
  fserver_release_form($form, $form_state);
}

/**
 * Implements hook_entity_info_alter().
 */
function fserver_entity_info_alter(&$entity_info) {
  // Set the entity class for projects and releases
  if (isset($entity_info['project'])) {
    $entity_info['project']['entity class'] = 'fserverProject';
    $entity_info['project']['access callback'] = 'fserver_project_access';
    $entity_info['project']['controller class'] = 'fserverProjectController';
  }

  if (isset($entity_info['release'])) {
    $entity_info['release']['entity class'] = 'fserverRelease';
    $entity_info['release']['access callback'] = 'fserver_release_access';
    $entity_info['release']['controller class'] = 'fserverReleaseController';
  }
}

/**
 * Default access callback for project entities
 */
function fserver_project_access($op, $project = NULL, $account = NULL) {
  return TRUE;
}

/**
 * Access callback for release entities
 */
function fserver_release_access($op, $release = NULL, $account = NULL) {
  return TRUE;
}

/**
 * Implements hook_field_formatter_info().
 */
function fserver_field_formatter_info() {
  return array(
    'file_size' => array(
      'label' => t('File Size'),
      'field types' => array('file'),
    ),
    'file_hash_md5' => array(
      'label' => t('File MD5'),
      'field types' => array('file'),
    ),
  );

}

/**
 * Implements hook_field_formatter_view().
 */
function fserver_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  $settings = $display['settings'];

  switch ($display['type']) {
    case 'file_size':
      foreach ($items as $delta => $item) {
        $element[$delta] = array('#markup' => $item['filesize']);
      }
    break;
    case 'file_hash_md5':
      foreach ($items as $delta => $item) {
        if (isset($item['filehash']['md5'])) {
          $element[$delta] = array('#markup' => $item['filehash']['md5']);
        }
        else {
          watchdog('fserver', 'No MD5 hash exists for fid: @fid', array('@fid' => $item['fid']), WATCHDOG_WARNING);
        }
      }
    break;
  }

  return $element;
}

/**
 * Generate the XML for a file field
 */
function _fserver_release_file_format($item) {

  $archive_type = '';
  if ('.tar.gz' == drupal_substr($item['filename'], -7)) {
    $archive_type = 'tar.gz';
  }
  elseif ('.tar' == drupal_substr($item['filename'], -4)) {
    $archive_type = 'tar';
  }
  elseif ('.tgz' == drupal_substr($item['filename'], -4)) {
    $archive_type = 'tgz';
  }
  elseif ('.zip' == drupal_substr($item['filename'], -4)) {
    $archive_type = 'zip';
  }

  $file['archive_type'] = $archive_type;

  $file['url'] = file_create_url($item['uri']);
  $file['md5'] = $item['filehash']['md5'];
  $file['size'] = check_plain($item['filesize']);
  $file['filedate'] = $item['timestamp'];

  return $file;
}

/**
 * Check if project exists
 *
 * @param string $shortname
 *  Project short name
 *
 * @return boolean
 *  Returns TRUE if a project by that name exists, FALSE otherwise.
 */
function fserver__project_exists($shortname) {
  $query = new EntityFieldQuery();
  $project = $query
    ->EntityCondition("entity_type", "project")
    ->propertyCondition("short_name", $shortname)
    ->execute();
  if (!isset($project['project'])) {
    return FALSE;
  }
  else {
    return TRUE;
  }
}

/**
 * Create an fserver project
 *
 * $project array(
 *   'title' => 'Long Project Tile',
 *   'type' => 'module', // Either module, distribution, or theme
 *   'short_name' => 'project_name',
 *   'recommended_major => 1,  // Optional
 *   'supported_majors' => '1',  // Optional
 *   'link' => 'project link',  // Optional
 *   'project_status' => 'published',  // Optional
 * );
 */
function fserver__project_create($project) {
  $entity = entity_create('project', $project);
  if ($entity === FALSE) {
    return FALSE;
  }
  return entity_save('project', $entity);
}

/**
 * Load an fserver project by shortname
 *
 * @param string $shortname
 *  Project shortname
 */
function fserver__project_load($shortname) {
  $query = new EntityFieldQuery();
  $project = $query
    ->EntityCondition("entity_type", "project")
    ->propertyCondition("short_name", $shortname)
    ->execute();
  if (!isset($project['project'])) {
    return FALSE;
  }

  $project = array_keys($project['project']);
  $project = entity_load('project', $project);
  return array_pop($project);
}

/**
 *  Update an fserver project
 */
function fserver__project_update($project) {
  return entity_save('project', (object) $project);
}

/**
 * Delete an fserver project
 */
function fserver__project_delete($shortname) {
  $project = fserver__project_load($shortname);
  if ($project === FALSE) {
    return FALSE;
  }
  return entity_delete('project', $project->id);
}

/**
 * Create an fserver release
 *
 * $release array(
 *   'project_short_name' => 'project_name',
 *   'api' = '7.x',
 *   'type' => 'release',
 *   'version_major' => '1',
 *   'version_patch' => '',  // Optional
 *   'version_extra' => 'dev',  // Optional
 * );
 */
function fserver__release_create($release) {
  $entity = entity_create('release', $release);
  if ($entity === FALSE) {
    return FALSE;
  }
  // @todo - fix this: entity_save should return one of: SAVED_UPDATED or SAVED_NEW constants, but currently returns false
  if (entity_save('release', $entity)) {
    return $entity;
  }
  //return FALSE;
  return $entity;
}

/**
 * Load an fserver release
 */
function fserver__release_load($name) {
  $query = new EntityFieldQuery();
  $release = $query
    ->EntityCondition("entity_type", "release")
    ->propertyCondition("name", $name)
    ->execute();
  if (!isset($release['release'])) {
    return FALSE;
  }

  $release = array_keys($release['release']);
  $release = entity_load('release', $release);
  return array_pop($release);
}

/**
 * Load all release entities for a given project
 *
 * Note that the dev release will also be the last item in the array.
 *
 * @param string $shortname
 *  Project short name
 * @param string $api
 *  API version
 * @return array|boolean
 *  Returns an array of entities, FALSE otherwise.
 */
function fserver__release_load_by_project($shortname, $api) {
  $query = new EntityFieldQuery();
  $releases = $query
    ->EntityCondition("entity_type", "release")
    ->propertyCondition("project_short_name", $shortname)
    ->propertyCondition("api", $api)
    ->propertyOrderBy('date', 'DESC')
    ->execute();
  if (!isset($releases['release'])) {
    return FALSE;
  }

  $releases = array_keys($releases['release']);
  $releases = entity_load('release', $releases);

  // Append dev release to the end of the array
  foreach ($releases as $id => $release) {
    if ($release->version_extra == 'dev') {
      unset($releases[$id]);
      $releases[] = $release;
      break;
    }
  }

  return $releases;
}

/**
 * Update an fserver release
 */
function fserver__release_update($release) {
  return entity_save('release', (object) $release);
}

/**
 * Delete an fserver release
 */
function fserver__release_delete($name) {
  $release = fserver__release_load($name);
  if ($release === FALSE) {
    return FALSE;
  }
  return entity_delete('release', $release->id);
}

/**
 * Base class for Project entities
 */
class fserverProject extends Entity {
  public function __construct($values = array()) {
    // @todo add constructor validation
    parent::__construct($values, 'project');
  }

  public function next_version($api, $release_type = NULL) {
    // retrieve existing releases for this project
    $query = new EntityFieldQuery();
    $results = $query->entityCondition('entity_type', 'release')
                     ->fieldCondition('field_project_reference', 'target_id', $this->id)
                     ->propertyCondition('api', $api)
                     //->propertyCondition('version_extra', $release_type, 'STARTS_WITH')
                     ->propertyOrderBy('date', 'DESC')
                     ->execute();

    if (!empty($results['release'])) {
      $reltypes = array('dev', 'alpha', 'beta', 'rc', 'full');
      $tag = '';
      // First, we find the latest non-dev release created for this project.
      $latest_non_dev = array_reduce($results['release'], function($carry, $item) {
        $release = entity_load_single('release', $item->id);
        if ($release->version_extra != 'dev') {
          if (!isset($carry)) {
            return $release;
          }
          else {
            $carry_dt = new DateObject($carry->date);
            $rel_dt = new DateObject($release->date);
            if ($carry_dt->difference($rel_dt, 'seconds', FALSE) > 0) {
              return $release;
            }
            else {
              return $carry;
            }
          }
        }
        return $carry;
      });

      $latest_extra_type = !empty($latest_non_dev->version_extra) ? drupal_substr($latest_non_dev->version_extra, 0, drupal_strlen($latest_non_dev->version_extra)-1) : '';
      // Next, check release logic and build & return the tag
      if (!$latest_non_dev) {
        // latest release is a dev release.  Next release will drop the .x (for patch version) and simply be .1
        $latest_dev = array_reduce($results['release'], function($carry, $item) {
          $release = entity_load_single('release', $item->id);
          if ($release->version_extra == 'dev') {
            if (!isset($carry)) {
              return $release;
            }
            else {
              $carry_dt = new DateObject($carry->date);
              $rel_dt = new DateObject($release->date);
              if ($carry_dt->difference($rel_dt, 'seconds', FALSE) > 0) {
                return $release;
              }
              else {
                return $carry;
              }
            }
          }
          return $carry;
        });

        $tag = $latest_dev->api . '-' . $latest_dev->version_major . '.0';
        if (isset($release_type) && $release_type != 'full') {
          $tag .= '-' . $release_type . '1';
        }
        return $tag;
      }
      else if (isset($release_type) && !empty($release_type)) {
        if ('full' == $release_type) {
          if (empty($latest_non_dev->version_extra)) {
            // latest version is a full version, next full will increment minor/patch version
            $tag = $latest_non_dev->api . '-' . $latest_non_dev->version_major . '.' . (intval($latest_non_dev->version_patch) + 1);
          }
          else {
            // latest release is alpha/beta/rc, next full will drop the extra and simply be the api-major.minor version
            $tag = $latest_non_dev->api . '-' . $latest_non_dev->version_major . '.' . intval($latest_non_dev->version_patch);
          }
        }
        else {
          if (empty($latest_extra_type)   // latest release is a full release, but requested tag is earlier in cycle
              || array_search($release_type, $reltypes) < array_search($latest_extra_type, $reltypes)) {
            // requesting a tag earlier in the release cycle than the most recent release, fail
            return FALSE;
          }
          else if (array_search($release_type, $reltypes) > array_search($latest_extra_type, $reltypes)) {
            // moving to a later phase in the release cycle, set extra version back to 1
            $extra_version = 1;
          }
          else {
            // moving one version later in the same release phase, increment extra version
            $extra_version = intval(drupal_substr($latest_non_dev->version_extra, drupal_strlen($latest_non_dev->version_extra)-1)) + 1;
          }
          $tag = $latest_non_dev->api . '-' . $latest_non_dev->version_major . '.' . $latest_non_dev->version_patch . '-' . $release_type . $extra_version;
        }
      }
      else {
        // no release type specified, just increment in current release phase
        if (!empty($latest_extra_type)) {
          $extra_version = intval(drupal_substr($latest_non_dev->version_extra, drupal_strlen($latest_non_dev->version_extra)-1)) + 1;
          $tag = $latest_non_dev->api . '-' . $latest_non_dev->version_major . '.' . $latest_non_dev->version_patch . '-' . $latest_extra_type . $extra_version;
        }
        else {
          // latest version is a full version, next full will increment minor/patch version
          $tag = $latest_non_dev->api . '-' . $latest_non_dev->version_major . '.' . (intval($latest_non_dev->version_patch) + 1);
        }
      }
      return $tag;
    }
    // Did something go wrong?  Why are we here?  Maybe there are no existing releases...
    return FALSE;
  }
}

/**
 * Controller class for Project entities
 */
class fserverProjectController extends EntityAPIController {
  public function delete($ids, DatabaseTransaction $transaction = NULL) {

    $entities = $ids ? $this->load($ids) : FALSE;
    if (!$entities) {
      // Do nothing, in case invalid or no ids have been passed.
      return;
    } else {
      foreach ($entities as $entity) {
        $query = new EntityFieldQuery();
        $releases = $query
          ->entityCondition('entity_type', 'release')
          ->propertyCondition('project_short_name', $entity->short_name)
          ->execute();
        if (isset($releases['release'])) {
          entity_delete_multiple('release', array_keys($releases['release']));
        }
      }
    }
    parent::delete($ids, $transaction);
  }
}

/**
 * Base class for Release entities
 */
class fserverRelease extends Entity {
  public function __construct($values = array()) {
    // @todo add release validation
    parent::__construct($values, 'release');

    $this->generateReleaseName($values);
  }

  /**
   * Generate release name
   *
   * Pattern: <project_name> <api_version>-<release_version>
   * Ex: views 7.x-1.x-dev
   *
   * @param array $args [optional]
   *  List of arguments passed into the constructor. Used to determine
   *  how the release object is being created.
   */
  public function generateReleaseName($args = array()) {

    if (isset($args['is_new']) and $args['is_new'] == TRUE) {
      // For now we do basic detection on new objects. But we
      // should instead detect if the values for the name field
      // are set.
      // @todo
    }
    else {
      if (!empty($this->version_patch) || ($this->version_patch == 0 && $this->version_extra != 'dev')) {
        $this->tag = $this->api . '-' . $this->version_major . '.' . $this->version_patch;
        $this->version = $this->tag;
      } else {
        $this->tag = $this->api . '-' . $this->version_major . '.x';
        $this->version = $this->tag;
      }
      if (!empty($this->version_extra)) {
        $this->version .= '-' . $this->version_extra;
      }

      $this->name = $this->project_short_name . ' ' . $this->version;
    }
  }
}

/**
 * Controller class for Release entities
 */
class fserverReleaseController extends EntityAPIController {
  public function save($entity, DatabaseTransaction $transaction = NULL) {
    $entity->date = time();
    $entity->generateReleaseName();
    parent::save($entity, $transaction);
  }
}

/**
 * Project and releases in one object.
 *
 * Used to generate the update XML for a given project.
 */
class fserverProjectRelease {
  protected $project;

  /**
   * Build a fserverProjectRelease object
   */
  public function __construct($project, $api) {
    if (is_object($project) and get_class($project) == 'fserverProject') {
      $this->project = $project;
      $this->prepareReleases($api);
      $this->prepareProject();
      $this->alterReleaseData();
    }
    else {
      $this->project = FALSE;
    }
  }

  public function getProject() {
    return $this->project;
  }

  private function prepareReleases($api) {
    $releases = fserver__release_load_by_project($this->project->short_name, $api);
    if (is_array($releases)) {
      foreach ($releases as &$release) {
        unset($release->id);
        unset($release->type);
        unset($release->project_short_name);
        unset($uid);

        // Build files array
        $files = array();
        foreach ($release->field_release_files[LANGUAGE_NONE] as $key => $file) {
          $files[$key] = _fserver_release_file_format($file);
        }
        $release->files = $files;

        // Clean out file fields
        unset($release->field_release_files);
        unset($release->field_release_notes);

        // Copy the first files entry into the main release XML as the default
        // download
        $release->download_link = $release->files[0]['url'];
        $release->mdhash = $release->files[0]['md5'];
        $release->filesize = $release->files[0]['size'];
      }
    }
    $this->project->releases = $releases;
  }

  /**
   * Prepare the project object
   */
  private function prepareProject() {
    unset($this->project->id);
    unset($this->project->field_compatibility);
  }

  /**
   * Allow other modules to alter the release data
   */
  private function alterReleaseData() {
    $project = $this->project;
    drupal_alter('fserver__project_release_data', $project);
    $this->project = $project;
  }
}
